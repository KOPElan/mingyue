@page "/file-manager"
@page "/file-manager/{InitialPath}"
@using MingYue.Models
@using MingYue.Services
@using MingYue.Utilities
@using Microsoft.AspNetCore.Components.Forms
@inject IFileManagementService FileService
@inject IFileUploadService UploadService
@inject IThumbnailService ThumbnailService
@inject IToastService ToastService
@inject ILogger<FileManager> Logger
@inject IJSRuntime JSRuntime

<PageTitle>File Manager - MingYue</PageTitle>

<div class="file-manager-container">
    <!-- Left Sidebar -->
    <div class="file-manager-sidebar">
        <!-- Create Button -->
        <FluentMenuButton class="sidebar-create-button" Text="Create" 
                         Appearance="Appearance.Accent"
                         Style="width: 100%;">
            <FluentMenuItem OnClick="@OpenCreateFolderDialog">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.FolderAdd())" Slot="start" />
                New Folder
            </FluentMenuItem>
            <FluentMenuItem OnClick="@OpenUploadDialog">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowUpload())" Slot="start" />
                Upload Files
            </FluentMenuItem>
        </FluentMenuButton>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Favorites Section -->
            @if (favoriteFolders.Any())
            {
                <div class="sidebar-section-title">Favorites</div>
                @foreach (var favorite in favoriteFolders)
                {
                    <div class="sidebar-nav-item" @onclick="@(() => NavigateToPath(favorite.Path))">
                        <FluentIcon Value="@(GetFavoriteIcon(favorite.Icon))" />
                        @favorite.Name
                    </div>
                }
            }

            <!-- Disks/Storage Section -->
            @if (availableDrives.Any())
            {
                <div class="sidebar-section-title">Disks</div>
                @foreach (var drive in availableDrives)
                {
                    var isActiveDisk = IsPathOnDisk(currentPath, drive.Path);
                    <div class="sidebar-nav-item @(isActiveDisk ? "active" : "")" @onclick="@(() => NavigateToPath(drive.Path))">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.HardDrive())" />
                        <div style="flex: 1;">
                            <div>@drive.Name</div>
                            <div style="font-size: 11px; color: var(--neutral-foreground-hint, #707070);">
                                @drive.UsedSizeDisplay / @drive.TotalSizeDisplay
                            </div>
                        </div>
                    </div>
                }
            }
        </nav>

        <!-- Storage Info -->
        @if (storageInfo.total > 0)
        {
            <div class="sidebar-storage">
                <div class="storage-info">
                    @FileUtilities.FormatSize(storageInfo.total - storageInfo.available) / @FileUtilities.FormatSize(storageInfo.total)
                </div>
                <div class="storage-bar">
                    <div class="storage-bar-fill" style="width: @((100.0 * (storageInfo.total - storageInfo.available) / storageInfo.total).ToString("F1"))%"></div>
                </div>
                <div class="storage-info">
                    @((100.0 * (storageInfo.total - storageInfo.available) / storageInfo.total).ToString("F1"))% used
                </div>
            </div>
        }
    </div>

    <!-- Main Content Area -->
    <div class="file-manager-main">
        <!-- Header -->
        <div class="file-manager-header">
            <div class="header-top">
                <!-- Search -->
                <FluentSearch @bind-Value="@searchQuery" 
                              @bind-Value:after="@OnSearchChanged"
                              Placeholder="Search files..."
                              Style="width: 400px;" 
                              Immediate="false"
                              ImmediateDelay="500" />

                <!-- Actions -->
                <div class="header-actions">
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@RefreshFiles" Title="Refresh">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowClockwise())" />
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@ToggleViewMode" Title="@(viewMode == ViewMode.List ? "Grid View" : "List View")">
                        <FluentIcon Value="@GetViewModeIcon()" />
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenFavoritesDialog" Title="Manage Favorites">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Star())" />
                    </FluentButton>
                </div>
            </div>

            <!-- Breadcrumb -->
            <div class="breadcrumb-nav">
                <div class="breadcrumb-item" @onclick="@(() => NavigateToPath("/"))">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Folder())" />
                </div>
                @foreach (var segment in GetPathSegments())
                {
                    var capturedPath = segment.Path;
                    <span class="breadcrumb-separator">â€º</span>
                    <div class="breadcrumb-item" @onclick="@(() => NavigateToPath(capturedPath))">
                        @segment.Name
                    </div>
                }
            </div>
        </div>

        <!-- Content Area -->
        @if (isLoading)
        {
            <div class="empty-state">
                <FluentProgressRing />
            </div>
        }
        else if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="empty-state">
                <FluentMessageBar Intent="MessageIntent.Error">
                    @errorMessage
                </FluentMessageBar>
            </div>
        }
        else if (DisplayedFiles.Count == 0)
        {
            <div class="empty-state">
                <div class="empty-state-icon">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Folder())" />
                </div>
                <div class="empty-state-title">
                    @(string.IsNullOrEmpty(searchQuery) ? "This folder is empty" : "No files found")
                </div>
                <div class="empty-state-text">
                    @(string.IsNullOrEmpty(searchQuery) ? "Upload files or create a new folder to get started" : "Try adjusting your search query")
                </div>
            </div>
        }
        else
        {
            @if (viewMode == ViewMode.Grid)
            {
                <div class="file-grid-container">
                    <div class="file-grid">
                        @foreach (var item in DisplayedFiles)
                        {
                            var isSelected = selectedItems.Contains(item);
                            <div class="file-card @(isSelected ? "selected" : "")" 
                                 @onclick="@((e) => OnCardClick(item, e))"
                                 @ondblclick="@(() => OnItemClick(item))">
                                @if (isSelected)
                                {
                                    <div class="file-card-checkbox">
                                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Filled.Size20.CheckmarkCircle())" Color="@Color.Accent" />
                                    </div>
                                }
                                <div class="file-card-thumbnail">
                                    @if (item.IsDirectory)
                                    {
                                        <div class="file-card-icon">
                                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Folder())" Color="@Color.Accent" />
                                        </div>
                                    }
                                    else if (IsImageFile(item))
                                    {
                                        @if (!string.IsNullOrEmpty(item.ThumbnailData))
                                        {
                                            <img src="@item.ThumbnailData" alt="@item.Name" />
                                        }
                                        else
                                        {
                                            <div class="file-card-icon">
                                                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Image())" />
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        <div class="file-card-icon">
                                            <FluentIcon Value="@GetFileIcon(item)" />
                                        </div>
                                    }
                                </div>
                                <div class="file-card-name" title="@item.Name">@item.Name</div>
                                <div class="file-card-meta">@item.SizeDisplay</div>
                            </div>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="file-list-container">
                    <div class="file-list-header">
                        <div>Name</div>
                        <div>Size</div>
                        <div>Modified</div>
                        <div>Actions</div>
                    </div>
                    @foreach (var item in DisplayedFiles)
                    {
                        <div class="file-list-row">
                            <div class="file-list-name">
                                <FluentIcon Value="@GetFileIcon(item)" />
                                <span class="file-list-name-text" @onclick="@(() => OnItemClick(item))">
                                    @item.Name
                                </span>
                            </div>
                            <div>@item.SizeDisplay</div>
                            <div>@item.LastModified.ToString("yyyy-MM-dd HH:mm")</div>
                            <div class="file-list-actions">
                                @if (!item.IsDirectory)
                                {
                                    <FluentButton Appearance="Appearance.Lightweight" 
                                                OnClick="@(() => DownloadFile(item))"
                                                Title="Download">
                                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowDownload())" />
                                    </FluentButton>
                                    @if (IsImageFile(item))
                                    {
                                        <FluentButton Appearance="Appearance.Lightweight" 
                                                    OnClick="@(() => PreviewImage(item))"
                                                    Title="Preview">
                                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Eye())" />
                                        </FluentButton>
                                    }
                                }
                                <FluentButton Appearance="Appearance.Lightweight" 
                                            OnClick="@(() => OpenRenameDialog(item))"
                                            Title="Rename">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Rename())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight" 
                                            OnClick="@(() => OpenCopyMoveDialog(item, false))"
                                            Title="Copy">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Copy())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight" 
                                            OnClick="@(() => OpenCopyMoveDialog(item, true))"
                                            Title="Move">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowRight())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight" 
                                            OnClick="@(() => DeleteItem(item))"
                                            Title="Delete">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Delete())" Color="Color.Error" />
                                </FluentButton>
                            </div>
                        </div>
                    }
                </div>
            }
        }
    </div>
    
    <!-- Bottom Action Bar (shown when items are selected) -->
    @if (selectedItems.Any())
    {
        <div class="bottom-action-bar">
            <div class="action-bar-content">
                <div class="action-bar-info">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.CheckmarkCircle())" Color="@Color.Accent" />
                    <span>@selectedItems.Count @(selectedItems.Count == 1 ? "item" : "items") selected</span>
                </div>
                <div class="action-bar-buttons">
                    @if (selectedItems.Count == 1)
                    {
                        <FluentButton Appearance="Appearance.Lightweight" OnClick="@RenameSelectedItem" Title="Rename">
                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Rename())" />
                            Rename
                        </FluentButton>
                    }
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@DownloadSelected" Title="Download">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowDownload())" />
                        Download
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenMoveDialog" Title="Move">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowMove())" />
                        Move
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenCopyDialog" Title="Copy">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Copy())" />
                        Copy
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@DeleteSelected" Title="Delete">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Delete())" Color="@Color.Error" />
                        Delete
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@(() => selectedItems.Clear())" Title="Clear Selection">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Dismiss())" />
                    </FluentButton>
                </div>
            </div>
        </div>
    }
</div>

<!-- Create Folder Dialog -->
<FluentDialog @ref="createFolderDialog" @bind-Hidden="@isCreateFolderDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.FolderAdd())" />
            <FluentLabel Typo="Typography.PaneHeader">Create New Folder</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="newFolderName" 
                       Label="Folder Name" 
                       Required="true"
                       Style="width: 100%;"
                       @onkeydown="@(async (e) => { if (e.Key == "Enter") await CreateFolder(); })" />
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@CreateFolder">Create</FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isCreateFolderDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Upload Dialog with Dropzone -->
<FluentDialog @ref="uploadDialog" @bind-Hidden="@isUploadDialogHidden" TrapFocus="true" Modal="true" Style="min-width: 600px;">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.ArrowUpload())" />
            <FluentLabel Typo="Typography.PaneHeader">Upload Files</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="15">
            <!-- Dropzone Area -->
            <div id="dropzone-upload" class="dropzone-container"></div>
            
            <!-- Upload Progress -->
            @if (uploadingFiles.Any())
            {
                <div class="upload-progress-container">
                    <FluentLabel Typo="Typography.Body" Style="font-weight: 600; margin-bottom: 8px;">
                        Uploading @uploadingFiles.Count file(s)...
                    </FluentLabel>
                    @foreach (var file in uploadingFiles.Take(5))
                    {
                        <div class="upload-file-progress">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="font-size: 13px;">@file.Key</span>
                                <span style="font-size: 13px; color: var(--accent-fill-rest);">@file.Value%</span>
                            </div>
                            <FluentProgress Min="0" Max="100" Value="@file.Value" />
                        </div>
                    }
                    @if (uploadingFiles.Count > 5)
                    {
                        <FluentLabel Typo="Typography.Body">and @(uploadingFiles.Count - 5) more...</FluentLabel>
                    }
                </div>
            }
            
            @if (!string.IsNullOrEmpty(uploadStatusMessage))
            {
                <FluentMessageBar Intent="@uploadMessageIntent">
                    @uploadStatusMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" 
                    OnClick="@StartUpload" 
                    Disabled="@isUploading">
            Start Upload
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" 
                    OnClick="@CancelUpload"
                    Disabled="@isUploading">
            @(isUploading ? "Close" : "Cancel")
        </FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Rename Dialog -->
<FluentDialog @ref="renameDialog" @bind-Hidden="@isRenameDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Rename())" />
            <FluentLabel Typo="Typography.PaneHeader">Rename</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="newItemName" 
                       Label="New Name" 
                       Required="true"
                       Style="width: 100%;"
                       @onkeydown="@(async (e) => { if (e.Key == "Enter") await RenameItem(); })" />
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@RenameItem">Rename</FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isRenameDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Copy/Move Dialog -->
<FluentDialog @ref="copyMoveDialog" @bind-Hidden="@isCopyMoveDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@GetCopyMoveIcon()" />
            <FluentLabel Typo="Typography.PaneHeader">@(isMoveOperation ? "Move" : "Copy") to...</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="destinationPath" 
                       Label="Destination Path" 
                       Required="true"
                       Placeholder="@currentPath"
                       Style="width: 100%;" />
        <FluentLabel Typo="Typography.Body">Current: @currentPath</FluentLabel>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@PerformCopyMove">
            @(isMoveOperation ? "Move" : "Copy")
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isCopyMoveDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Image Preview Dialog -->
<FluentDialog @ref="previewDialog" @bind-Hidden="@isPreviewDialogHidden" TrapFocus="true" Modal="true" Style="max-width: 90vw; max-height: 90vh;">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Image())" />
            <FluentLabel Typo="Typography.PaneHeader">@previewFileName</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        @if (!string.IsNullOrEmpty(previewImageData))
        {
            <img src="@previewImageData" alt="Preview" style="max-width: 100%; max-height: 70vh; object-fit: contain;" />
        }
        else
        {
            <FluentProgressRing />
        }
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isPreviewDialogHidden = true)">Close</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Favorites Dialog -->
<FluentDialog @ref="favoritesDialog" @bind-Hidden="@isFavoritesDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Star())" />
            <FluentLabel Typo="Typography.PaneHeader">Manage Favorites</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
            <FluentButton Appearance="Appearance.Accent" OnClick="@AddCurrentToFavorites">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Add())" />
                Add Current Folder
            </FluentButton>
            @if (favoriteFolders.Any())
            {
                <FluentDivider />
                @foreach (var favorite in favoriteFolders)
                {
                    <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center">
                        <FluentIcon Value="@(GetFavoriteIcon(favorite.Icon))" />
                        <FluentLabel Style="flex: 1;">@favorite.Name</FluentLabel>
                        <FluentButton Appearance="Appearance.Lightweight" 
                                    OnClick="@(() => RemoveFromFavorites(favorite.Id))">
                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Delete())" Color="Color.Error" />
                        </FluentButton>
                    </FluentStack>
                }
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isFavoritesDialogHidden = true)">Close</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Delete Confirmation Dialog -->
<FluentDialog @ref="deleteDialog" @bind-Hidden="@isDeleteDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Delete())" Color="Color.Error" />
            <FluentLabel Typo="Typography.PaneHeader">Confirm Delete</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
            <FluentLabel>Are you sure you want to delete this @(itemToDelete?.IsDirectory == true ? "folder" : "file")?</FluentLabel>
            <FluentLabel Style="font-weight: bold;">@itemToDelete?.Name</FluentLabel>
            @if (itemToDelete?.IsDirectory == true)
            {
                <FluentMessageBar Intent="MessageIntent.Warning">
                    Warning: This will delete the folder and all its contents.
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@ConfirmDelete" Style="background-color: var(--error);">
            Delete
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isDeleteDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

@code {
    [Parameter]
    public string? InitialPath { get; set; }

    private enum ViewMode { List, Grid }
    
    private const string ParentDirectoryMarker = "..";

    private ViewMode viewMode = ViewMode.Grid;
    private string currentPath = "/";
    private List<FileItemInfo> fileItems = new();
    private List<FileItemInfo> DisplayedFiles => string.IsNullOrEmpty(searchQuery) ? fileItems : searchResults;
    private List<FileItemInfo> searchResults = new();
    private List<FavoriteFolder> favoriteFolders = new();
    private List<DriveItemInfo> availableDrives = new();
    private HashSet<FileItemInfo> selectedItems = new();
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private string searchQuery = string.Empty;
    private (long total, long available) storageInfo;

    // Dialog states
    private FluentDialog? createFolderDialog;
    private FluentDialog? uploadDialog;
    private FluentDialog? renameDialog;
    private FluentDialog? copyMoveDialog;
    private FluentDialog? previewDialog;
    private FluentDialog? favoritesDialog;
    private FluentDialog? deleteDialog;
    
    private bool isCreateFolderDialogHidden = true;
    private bool isUploadDialogHidden = true;
    private bool isRenameDialogHidden = true;
    private bool isCopyMoveDialogHidden = true;
    private bool isPreviewDialogHidden = true;
    private bool isFavoritesDialogHidden = true;
    private bool isDeleteDialogHidden = true;

    // Dialog data
    private string newFolderName = string.Empty;
    private string newItemName = string.Empty;
    private string destinationPath = string.Empty;
    private FileItemInfo? selectedItem;
    private FileItemInfo? itemToDelete;
    private bool isMoveOperation = false;
    private string previewImageData = string.Empty;
    private string previewFileName = string.Empty;

    // Upload
    private List<IBrowserFile> selectedFiles = new();
    private bool isUploading = false;
    private string uploadProgress = string.Empty;
    private Dictionary<string, int> uploadingFiles = new();
    private string uploadStatusMessage = string.Empty;
    private MessageIntent uploadMessageIntent = MessageIntent.Info;
    private DotNetObjectReference<FileManager>? dotNetHelper;

    private bool IsRootPath => string.IsNullOrEmpty(currentPath) || currentPath == "/" || currentPath == "\\";

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(InitialPath))
        {
            currentPath = InitialPath;
        }
        await LoadFavorites();
        await LoadDrives();
        await LoadFiles();
    }

    private async Task LoadDrives()
    {
        try
        {
            availableDrives = await FileService.GetDrivesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives");
        }
    }

    private void OnCardClick(FileItemInfo item, Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        // Ctrl/Cmd key for multi-select
        if (e.CtrlKey || e.MetaKey)
        {
            if (selectedItems.Contains(item))
            {
                selectedItems.Remove(item);
            }
            else
            {
                selectedItems.Add(item);
            }
        }
        // Shift key for range select (simple implementation)
        else if (e.ShiftKey && selectedItems.Any())
        {
            var lastSelected = selectedItems.Last();
            var startIndex = DisplayedFiles.IndexOf(lastSelected);
            var endIndex = DisplayedFiles.IndexOf(item);
            
            if (startIndex >= 0 && endIndex >= 0)
            {
                var start = Math.Min(startIndex, endIndex);
                var end = Math.Max(startIndex, endIndex);
                
                for (int i = start; i <= end; i++)
                {
                    selectedItems.Add(DisplayedFiles[i]);
                }
            }
        }
        // Single click without modifiers - select only this item
        else
        {
            selectedItems.Clear();
            selectedItems.Add(item);
        }
    }

    private async Task LoadThumbnails()
    {
        // Load thumbnails for image files in grid view
        if (viewMode != ViewMode.Grid)
        {
            // Clear thumbnail data when not in grid view to save memory
            foreach (var item in fileItems)
            {
                item.ThumbnailData = null;
            }
            return;
        }

        try
        {
            var imageFiles = fileItems.Where(f => !f.IsDirectory && IsImageFile(f)).ToList();
            
            // Load thumbnails in parallel for better performance
            var thumbnailTasks = imageFiles.Select(async item =>
            {
                try
                {
                    var thumbnailData = await ThumbnailService.GetThumbnailAsync(item.Path);
                    if (thumbnailData != null)
                    {
                        item.ThumbnailData = $"data:image/jpeg;base64,{Convert.ToBase64String(thumbnailData)}";
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Failed to load thumbnail for {Path}", item.Path);
                }
            });
            
            await Task.WhenAll(thumbnailTasks);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading thumbnails");
        }
    }

    /// <summary>
    /// Loads files and folders from the current path
    /// </summary>
    private async Task LoadFiles()
    {
        isLoading = true;
        errorMessage = string.Empty;
        
        try
        {
            fileItems = await FileService.GetFilesAsync(currentPath);
            
            // Sort: directories first, then by name
            fileItems = fileItems
                .OrderBy(f => f.IsDirectory ? 0 : 1)
                .ThenBy(f => f.Name)
                .ToList();

            // Get storage info for the drive containing current path
            try
            {
                storageInfo = await FileService.GetStorageInfoAsync(currentPath);
                StateHasChanged(); // Ensure UI updates with new storage info
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to get storage info for path: {Path}", currentPath);
                // Storage info is optional
                storageInfo = (0, 0);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading files from path: {Path}", currentPath);
            errorMessage = $"Failed to load files: {ex.Message}";
            ToastService.ShowError($"Failed to load files: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }

        // Load thumbnails after files are loaded
        await LoadThumbnails();
        
        // Force UI update to ensure storage info is displayed
        StateHasChanged();
    }

    private async Task LoadFavorites()
    {
        try
        {
            favoriteFolders = await FileService.GetFavoriteFoldersAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading favorite folders");
        }
    }

    private async Task RefreshFiles()
    {
        await LoadFiles();
        ToastService.ShowSuccess("Files refreshed");
    }

    private async Task NavigateUp()
    {
        if (!IsRootPath)
        {
            var parentPath = FileService.GetParentPath(currentPath);
            await NavigateToPath(parentPath);
        }
    }

    private async Task NavigateToPath(string path)
    {
        currentPath = path;
        searchQuery = string.Empty;
        searchResults.Clear();
        selectedItems.Clear(); // Clear selection when navigating
        await LoadFiles();
    }

    private async Task OnItemClick(FileItemInfo item)
    {
        if (item.IsDirectory)
        {
            await NavigateToPath(item.Path);
        }
        else if (IsImageFile(item))
        {
            await PreviewImage(item);
        }
        else
        {
            await DownloadFile(item);
        }
    }

    private bool IsPathOnDisk(string path, string diskPath)
    {
        // Normalize paths for comparison (handle both Unix and Windows separators)
        var normalizedPath = path.TrimEnd('/', '\\');
        var normalizedDiskPath = diskPath.TrimEnd('/', '\\');
        
        // Special handling for root path
        if (normalizedDiskPath == "" || normalizedDiskPath == "/")
        {
            normalizedDiskPath = "/";
            // Root disk is active only if path is exactly "/" or doesn't match any other disk
            // This will be handled by checking other disks first
            if (normalizedPath == "" || normalizedPath == "/")
            {
                return true;
            }
            // Check if path starts with any non-root disk path
            // If it does, then root is NOT active
            foreach (var drive in availableDrives)
            {
                var otherDiskPath = drive.Path.TrimEnd('/', '\\');
                if (otherDiskPath != "" && otherDiskPath != "/" && normalizedPath.StartsWith(otherDiskPath, StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }
            }
            // If no other disk matches, root is active
            return true;
        }
        
        // For non-root disks, check if path starts with disk path
        return normalizedPath.StartsWith(normalizedDiskPath, StringComparison.OrdinalIgnoreCase);
    }

    private List<(string Name, string Path)> GetPathSegments()
    {
        var segments = new List<(string, string)>();
        if (string.IsNullOrEmpty(currentPath) || currentPath == "/") return segments;

        var parts = currentPath.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
        var pathBuilder = new System.Text.StringBuilder();
        
        foreach (var part in parts)
        {
            pathBuilder.Append('/');
            pathBuilder.Append(part);
            segments.Add((part, pathBuilder.ToString()));
        }
        
        return segments;
    }

    private async Task ToggleViewMode()
    {
        viewMode = viewMode == ViewMode.List ? ViewMode.Grid : ViewMode.List;
        
        // Load thumbnails when switching to grid view
        if (viewMode == ViewMode.Grid)
        {
            await LoadThumbnails();
        }
    }

    #region File Operations

    private void OpenCreateFolderDialog()
    {
        newFolderName = string.Empty;
        isCreateFolderDialogHidden = false;
    }

    private async Task CreateFolder()
    {
        if (string.IsNullOrWhiteSpace(newFolderName))
        {
            ToastService.ShowWarning("Please enter a folder name");
            return;
        }

        // Validate folder name for path traversal attempts
        if (newFolderName.Contains("..") || 
            newFolderName.Contains("/") || 
            newFolderName.Contains("\\") ||
            Path.GetInvalidFileNameChars().Any(c => newFolderName.Contains(c)))
        {
            ToastService.ShowError("Invalid folder name. Please avoid special characters and path separators.");
            return;
        }

        try
        {
            var folderPath = Path.Combine(currentPath, newFolderName);
            await FileService.CreateDirectoryAsync(folderPath);
            ToastService.ShowSuccess($"Folder '{newFolderName}' created successfully");
            isCreateFolderDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating folder: {Name}", newFolderName);
            ToastService.ShowError($"Failed to create folder: {ex.Message}");
        }
    }

    private void DeleteItem(FileItemInfo item)
    {
        itemToDelete = item;
        isDeleteDialogHidden = false;
    }

    private async Task ConfirmDelete()
    {
        if (itemToDelete == null) return;

        try
        {
            if (itemToDelete.IsDirectory)
            {
                await FileService.DeleteDirectoryAsync(itemToDelete.Path);
            }
            else
            {
                await FileService.DeleteFileAsync(itemToDelete.Path);
            }
            
            ToastService.ShowSuccess($"'{itemToDelete.Name}' deleted successfully");
            isDeleteDialogHidden = true;
            itemToDelete = null;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting item: {Path}", itemToDelete?.Path);
            ToastService.ShowError($"Failed to delete: {ex.Message}");
            isDeleteDialogHidden = true;
            itemToDelete = null;
        }
    }

    private void OpenRenameDialog(FileItemInfo item)
    {
        selectedItem = item;
        newItemName = item.Name;
        isRenameDialogHidden = false;
    }

    private async Task RenameItem()
    {
        if (selectedItem == null || string.IsNullOrWhiteSpace(newItemName))
        {
            ToastService.ShowWarning("Please enter a new name");
            return;
        }

        try
        {
            var newPath = Path.Combine(Path.GetDirectoryName(selectedItem.Path) ?? currentPath, newItemName);
            await FileService.RenameAsync(selectedItem.Path, newPath);
            ToastService.ShowSuccess($"Renamed to '{newItemName}' successfully");
            isRenameDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming item: {Path}", selectedItem.Path);
            ToastService.ShowError($"Failed to rename: {ex.Message}");
        }
    }

    private void OpenCopyMoveDialog(FileItemInfo item, bool isMove)
    {
        selectedItem = item;
        isMoveOperation = isMove;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private async Task PerformCopyMove()
    {
        if (selectedItem == null || string.IsNullOrWhiteSpace(destinationPath))
        {
            ToastService.ShowWarning("Please enter a destination path");
            return;
        }

        try
        {
            var destPath = Path.Combine(destinationPath, selectedItem.Name);
            
            if (isMoveOperation)
            {
                await FileService.MoveAsync(selectedItem.Path, destPath);
                ToastService.ShowSuccess($"Moved '{selectedItem.Name}' successfully");
            }
            else
            {
                await FileService.CopyAsync(selectedItem.Path, destPath);
                ToastService.ShowSuccess($"Copied '{selectedItem.Name}' successfully");
            }
            
            isCopyMoveDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error {Operation} item: {Path}", isMoveOperation ? "moving" : "copying", selectedItem.Path);
            ToastService.ShowError($"Failed to {(isMoveOperation ? "move" : "copy")}: {ex.Message}");
        }
    }

    private async Task DownloadFile(FileItemInfo file)
    {
        try
        {
            var fileData = await FileService.DownloadFileAsync(file.Path);
            
            // Use JS interop to trigger download
            await JSRuntime.InvokeVoidAsync("downloadFile", file.Name, Convert.ToBase64String(fileData));
            ToastService.ShowSuccess($"Downloading '{file.Name}'");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading file: {Path}", file.Path);
            ToastService.ShowError($"Failed to download: {ex.Message}");
        }
    }

    #endregion

    #region Upload

    private async Task OpenUploadDialog()
    {
        uploadingFiles.Clear();
        uploadStatusMessage = string.Empty;
        isUploading = false;
        isUploadDialogHidden = false;
        
        // Initialize dropzone after dialog renders
        await Task.Delay(100);
        await InitializeDropzone();
    }

    private async Task InitializeDropzone()
    {
        try
        {
            // Wait a bit longer for dropzone script to load
            await Task.Delay(300);
            
            dotNetHelper = DotNetObjectReference.Create(this);
            var uploadUrl = "/api/files/upload-chunk";
            await JSRuntime.InvokeVoidAsync("initializeChunkedDropzone", 
                "dropzone-upload", 
                uploadUrl, 
                currentPath, 
                dotNetHelper,
                1048576); // 1MB chunks
        }
        catch (JSException jsEx) when (jsEx.Message.Contains("Dropzone is not defined"))
        {
            Logger.LogError(jsEx, "Dropzone library not loaded");
            uploadStatusMessage = "Upload component not ready. Please refresh the page.";
            uploadMessageIntent = MessageIntent.Error;
            ToastService.ShowError("Dropzone.js library failed to load. Please check your internet connection and refresh the page.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing dropzone");
            uploadStatusMessage = $"Failed to initialize upload: {ex.Message}";
            uploadMessageIntent = MessageIntent.Error;
            ToastService.ShowError("Failed to initialize upload component");
        }
    }

    private async Task StartUpload()
    {
        try
        {
            isUploading = true;
            uploadStatusMessage = "Starting upload...";
            uploadMessageIntent = MessageIntent.Info;
            StateHasChanged();
            
            await JSRuntime.InvokeVoidAsync("processDropzoneQueue", "dropzone-upload");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting upload");
            uploadStatusMessage = $"Failed to start upload: {ex.Message}";
            uploadMessageIntent = MessageIntent.Error;
            isUploading = false;
        }
    }

    private async Task CancelUpload()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("clearDropzone", "dropzone-upload");
            uploadingFiles.Clear();
            uploadStatusMessage = string.Empty;
            isUploadDialogHidden = true;
            isUploading = false;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error canceling upload");
        }
    }

    [JSInvokable]
    public Task OnUploadProgress(string filename, int progress, long bytesSent, long totalBytes)
    {
        uploadingFiles[filename] = progress;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnFileUploaded(string filename)
    {
        uploadingFiles.Remove(filename);
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnUploadError(string filename, string error)
    {
        uploadingFiles.Remove(filename);
        uploadStatusMessage = $"Error uploading {filename}: {error}";
        uploadMessageIntent = MessageIntent.Error;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAllUploadsComplete()
    {
        uploadStatusMessage = "All files uploaded successfully!";
        uploadMessageIntent = MessageIntent.Success;
        isUploading = false;
        StateHasChanged();
        
        await Task.Delay(1500);
        await LoadFiles();
        isUploadDialogHidden = true;
    }

    private void HandleFileSelection(InputFileChangeEventArgs e)
    {
        selectedFiles = e.GetMultipleFiles(100).ToList();
    }

    private async Task UploadFiles()
    {
        if (!selectedFiles.Any()) return;

        isUploading = true;
        var uploadedCount = 0;

        try
        {
            foreach (var file in selectedFiles)
            {
                // Validate filename for path traversal attempts
                if (string.IsNullOrWhiteSpace(file.Name) || 
                    file.Name.Contains("..") || 
                    file.Name.Contains("/") || 
                    file.Name.Contains("\\") ||
                    Path.GetInvalidFileNameChars().Any(c => file.Name.Contains(c)))
                {
                    ToastService.ShowError($"Invalid filename: {file.Name}");
                    continue;
                }

                uploadProgress = $"{uploadedCount + 1} / {selectedFiles.Count}";
                StateHasChanged();

                using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 1024); // 1GB max
                await FileService.UploadFileStreamAsync(currentPath, file.Name, stream, file.Size);
                uploadedCount++;
            }

            ToastService.ShowSuccess($"Uploaded {uploadedCount} file(s) successfully");
            isUploadDialogHidden = true;
            selectedFiles.Clear();
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error uploading files");
            ToastService.ShowError($"Upload failed: {ex.Message}");
        }
        finally
        {
            isUploading = false;
            uploadProgress = string.Empty;
        }
    }

    #endregion

    #region Preview

    private async Task PreviewImage(FileItemInfo file)
    {
        previewFileName = file.Name;
        previewImageData = string.Empty;
        isPreviewDialogHidden = false;

        try
        {
            // Check file size before loading (e.g., warn if > 10MB)
            var fileInfo = new System.IO.FileInfo(file.Path);
            if (fileInfo.Length > 10 * 1024 * 1024) // 10MB limit for preview
            {
                ToastService.ShowWarning($"File is large ({fileInfo.Length / 1024 / 1024}MB). Preview may be slow.");
            }

            var imageData = await FileService.DownloadFileAsync(file.Path);
            var base64 = Convert.ToBase64String(imageData);
            var mimeType = GetMimeType(file.Extension);
            previewImageData = $"data:{mimeType};base64,{base64}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading image preview: {Path}", file.Path);
            ToastService.ShowError($"Failed to load preview: {ex.Message}");
            isPreviewDialogHidden = true;
        }
    }

    private bool IsImageFile(FileItemInfo file)
    {
        if (file.IsDirectory) return false;
        var ext = file.Extension.ToLowerInvariant();
        return ext is ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" or ".svg";
    }

    private string GetMimeType(string extension)
    {
        return extension.ToLowerInvariant() switch
        {
            ".jpg" or ".jpeg" => "image/jpeg",
            ".png" => "image/png",
            ".gif" => "image/gif",
            ".bmp" => "image/bmp",
            ".webp" => "image/webp",
            ".svg" => "image/svg+xml",
            _ => "application/octet-stream"
        };
    }

    #endregion

    #region Search

    private async Task OnSearchChanged()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            searchResults.Clear();
            return;
        }

        try
        {
            searchResults = await FileService.SearchFilesAsync(currentPath, searchQuery);
            ToastService.ShowInfo($"Found {searchResults.Count} items");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error searching files: {Query}", searchQuery);
            ToastService.ShowError($"Search failed: {ex.Message}");
        }
    }

    #endregion

    #region Favorites

    private void OpenFavoritesDialog()
    {
        isFavoritesDialogHidden = false;
    }

    private async Task AddCurrentToFavorites()
    {
        try
        {
            var folderName = Path.GetFileName(currentPath);
            if (string.IsNullOrEmpty(folderName))
            {
                folderName = currentPath;
            }

            await FileService.AddFavoriteFolderAsync(folderName, currentPath);
            await LoadFavorites();
            ToastService.ShowSuccess($"Added '{folderName}' to favorites");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding favorite folder: {Path}", currentPath);
            ToastService.ShowError($"Failed to add favorite: {ex.Message}");
        }
    }

    private async Task RemoveFromFavorites(int id)
    {
        try
        {
            await FileService.RemoveFavoriteFolderAsync(id);
            await LoadFavorites();
            ToastService.ShowSuccess("Removed from favorites");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error removing favorite folder: {Id}", id);
            ToastService.ShowError($"Failed to remove favorite: {ex.Message}");
        }
    }

    #endregion

    #region Icons

    private Icon GetFileIcon(FileItemInfo item)
    {
        if (item.IsDirectory)
        {
            return new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Folder();
        }

        return item.Extension.ToLowerInvariant() switch
        {
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" or ".svg" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Image(),
            ".pdf" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.DocumentPdf(),
            ".doc" or ".docx" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.DocumentText(),
            ".xls" or ".xlsx" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.DocumentTable(),
            ".ppt" or ".pptx" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.DocumentText(),
            ".txt" or ".log" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.DocumentText(),
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.FolderZip(),
            ".mp3" or ".wav" or ".flac" or ".m4a" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.MusicNote2(),
            ".mp4" or ".avi" or ".mkv" or ".mov" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Video(),
            ".cs" or ".js" or ".ts" or ".py" or ".java" or ".cpp" or ".c" or ".h" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Code(),
            ".html" or ".css" or ".json" or ".xml" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Code(),
            _ => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Document()
        };
    }

    private Icon GetFavoriteIcon(string iconName)
    {
        return iconName.ToLowerInvariant() switch
        {
            "folder" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder(),
            "star" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Star(),
            "home" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Home(),
            "document" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Document(),
            "image" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Image(),
            "video" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Video(),
            "music" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.MusicNote2(),
            _ => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder()
        };
    }

    private Icon GetViewModeIcon()
    {
        return viewMode == ViewMode.List 
            ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Grid() 
            : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.TextBulletList();
    }

    private Icon GetCopyMoveIcon()
    {
        return isMoveOperation 
            ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.ArrowRight() 
            : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Copy();
    }

    #endregion

    #region Batch Operations

    private async Task DownloadSelected()
    {
        if (!selectedItems.Any()) return;

        try
        {
            if (selectedItems.Count == 1)
            {
                // Single file download
                var item = selectedItems.First();
                if (!item.IsDirectory)
                {
                    await DownloadFile(item);
                }
                else
                {
                    ToastService.ShowInfo("Folder download will be packaged as ZIP");
                    await DownloadAsZip();
                }
            }
            else
            {
                // Multiple items - create ZIP
                await DownloadAsZip();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading selected items");
            ToastService.ShowError($"Download failed: {ex.Message}");
        }
    }

    private async Task DownloadAsZip()
    {
        string? tempZipPath = null;
        
        try
        {
            ToastService.ShowInfo("Preparing ZIP archive...");
            
            // Create a temporary zip file
            tempZipPath = Path.Combine(Path.GetTempPath(), $"download_{Guid.NewGuid()}.zip");
            
            using (var zipArchive = System.IO.Compression.ZipFile.Open(tempZipPath, System.IO.Compression.ZipArchiveMode.Create))
            {
                foreach (var item in selectedItems)
                {
                    if (item.IsDirectory)
                    {
                        // Add directory recursively
                        await AddDirectoryToZip(zipArchive, item.Path, item.Name);
                    }
                    else
                    {
                        // Add file
                        var fileData = await FileService.DownloadFileAsync(item.Path);
                        var entry = zipArchive.CreateEntry(item.Name);
                        using var entryStream = entry.Open();
                        await entryStream.WriteAsync(fileData);
                    }
                }
            }

            // Download the zip file
            var zipData = await File.ReadAllBytesAsync(tempZipPath);
            var zipFileName = selectedItems.Count == 1 
                ? $"{selectedItems.First().Name}.zip" 
                : $"download_{DateTime.Now:yyyyMMdd_HHmmss}.zip";
                
            await JSRuntime.InvokeVoidAsync("downloadFile", zipFileName, Convert.ToBase64String(zipData));
            
            ToastService.ShowSuccess($"Downloaded {selectedItems.Count} item(s) as ZIP");
            selectedItems.Clear();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating ZIP archive");
            ToastService.ShowError($"Failed to create ZIP: {ex.Message}");
        }
        finally
        {
            // Clean up temp file
            if (tempZipPath != null && File.Exists(tempZipPath))
            {
                try
                {
                    File.Delete(tempZipPath);
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Failed to delete temporary ZIP file: {Path}", tempZipPath);
                }
            }
        }
    }

    private async Task AddDirectoryToZip(System.IO.Compression.ZipArchive zipArchive, string sourcePath, string entryName)
    {
        var files = await FileService.GetFilesAsync(sourcePath);
        
        foreach (var file in files)
        {
            if (file.Name == ParentDirectoryMarker) continue;
            
            var relativePath = Path.Combine(entryName, file.Name);
            
            if (file.IsDirectory)
            {
                await AddDirectoryToZip(zipArchive, file.Path, relativePath);
            }
            else
            {
                try
                {
                    var fileData = await FileService.DownloadFileAsync(file.Path);
                    var entry = zipArchive.CreateEntry(relativePath);
                    using var entryStream = entry.Open();
                    await entryStream.WriteAsync(fileData);
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Failed to add file to ZIP: {Path}", file.Path);
                }
            }
        }
    }

    private void OpenMoveDialog()
    {
        if (!selectedItems.Any()) return;
        
        isMoveOperation = true;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private void OpenCopyDialog()
    {
        if (!selectedItems.Any()) return;
        
        isMoveOperation = false;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private async Task DeleteSelected()
    {
        if (!selectedItems.Any()) return;

        var itemNames = string.Join(", ", selectedItems.Take(3).Select(i => i.Name));
        if (selectedItems.Count > 3)
        {
            itemNames += $" and {selectedItems.Count - 3} more";
        }

        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", 
            $"Are you sure you want to delete {selectedItems.Count} item(s)?\n\n{itemNames}");

        if (!confirmed) return;

        try
        {
            var successCount = 0;
            var failCount = 0;

            foreach (var item in selectedItems.ToList())
            {
                try
                {
                    if (item.IsDirectory)
                    {
                        await FileService.DeleteDirectoryAsync(item.Path);
                    }
                    else
                    {
                        await FileService.DeleteFileAsync(item.Path);
                    }
                    successCount++;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error deleting item: {Path}", item.Path);
                    failCount++;
                }
            }

            if (successCount > 0)
            {
                ToastService.ShowSuccess($"Deleted {successCount} item(s) successfully");
            }
            if (failCount > 0)
            {
                ToastService.ShowError($"Failed to delete {failCount} item(s)");
            }

            selectedItems.Clear();
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in batch delete");
            ToastService.ShowError($"Delete operation failed: {ex.Message}");
        }
    }

    private void RenameSelectedItem()
    {
        if (selectedItems.Count != 1) return;
        
        var item = selectedItems.First();
        OpenRenameDialog(item);
        selectedItems.Clear();
    }

    #endregion
}
