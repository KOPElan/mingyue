@page "/file-manager"
@page "/file-manager/{InitialPath}"
@using MingYue.Models
@using MingYue.Services
@using MingYue.Utilities
@using Microsoft.AspNetCore.Components.Forms
@inject IFileManagementService FileService
@inject IFileUploadService UploadService
@inject IThumbnailService ThumbnailService
@inject IFileIndexService FileIndexService
@inject IScheduledTaskService ScheduledTaskService
@inject IToastService ToastService
@inject ILogger<FileManager> Logger
@inject IJSRuntime JSRuntime

<PageTitle>File Manager - MingYue</PageTitle>

<div class="file-manager-container">
    <!-- Left Sidebar -->
    <div class="file-manager-sidebar">
        <!-- Create Button -->
        <FluentMenuButton class="sidebar-create-button" Text="Create"
                          Appearance="Appearance.Accent"
                          Style="width: 100%;">
            <FluentMenuItem OnClick="@OpenCreateFolderDialog">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.FolderAdd())" Slot="start" />
                New Folder
            </FluentMenuItem>
            <FluentMenuItem OnClick="@OpenUploadDialog">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowUpload())" Slot="start" />
                Upload Files
            </FluentMenuItem>
        </FluentMenuButton>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Favorites Section -->
            @if (favoriteFolders.Any())
            {
                <div class="sidebar-section-title">Favorites</div>
                @foreach (var favorite in favoriteFolders)
                {
                    <div class="sidebar-nav-item" @onclick="@(() => NavigateToPath(favorite.Path))">
                        <FluentIcon Value="@(GetFavoriteIcon(favorite.Icon))" />
                        @favorite.Name
                    </div>
                }
            }

            <!-- Disks/Storage Section -->
            @if (availableDrives.Any())
            {
                <div class="sidebar-section-title">Disks</div>
                @foreach (var drive in availableDrives)
                {
                    var isActiveDisk = IsPathOnDisk(currentPath, drive.Path);
                    <div class="sidebar-nav-item @(isActiveDisk ? "active" : "")" @onclick="@(() => NavigateToPath(drive.Path))">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.HardDrive())" />
                        <div style="flex: 1;">
                            <div>@drive.Name</div>
                            <div style="font-size: 11px; color: var(--neutral-foreground-hint, #707070);">
                                @drive.UsedSizeDisplay / @drive.TotalSizeDisplay
                            </div>
                        </div>
                    </div>
                }
            }
        </nav>

        <!-- Storage Info -->
        @if (storageInfo.total > 0)
        {
            <div class="sidebar-storage">
                <div class="storage-info">
                    @FileUtilities.FormatSize(storageInfo.total - storageInfo.available) / @FileUtilities.FormatSize(storageInfo.total)
                </div>
                <div class="storage-bar">
                    <div class="storage-bar-fill" style="width: @((100.0 * (storageInfo.total - storageInfo.available) / storageInfo.total).ToString("F1"))%"></div>
                </div>
                <div class="storage-info">
                    @((100.0 * (storageInfo.total - storageInfo.available) / storageInfo.total).ToString("F1"))% used
                </div>
            </div>
        }
    </div>

    <!-- Main Content Area -->
    <div class="file-manager-main">
        <!-- Header -->
        <div class="file-manager-header">
            <div class="header-top">
                <!-- Search -->
                <FluentSearch @bind-Value="@searchQuery"
                              @bind-Value:after="@OnSearchChanged"
                              Placeholder="Search files..."
                              Style="width: 400px;"
                              Immediate="false"
                              ImmediateDelay="500" />

                <!-- Actions -->
                <div class="header-actions">
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@RefreshFiles" Title="Refresh">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowClockwise())" />
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@ToggleViewMode" Title="@(viewMode == ViewMode.List ? "Grid View" : "List View")">
                        <FluentIcon Value="@GetViewModeIcon()" />
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenFavoritesDialog" Title="Manage Favorites">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Star())" />
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenBackgroundTaskDialog" Title="Create Background Tasks">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.TaskListSquareLtr())" />
                    </FluentButton>
                </div>
            </div>

            <!-- Breadcrumb -->
            <div class="breadcrumb-nav">
                <div class="breadcrumb-item" @onclick="@(() => NavigateToPath("/"))">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Folder())" />
                </div>
                @foreach (var segment in GetPathSegments())
                {
                    var capturedPath = segment.Path;
                    <span class="breadcrumb-separator">â€º</span>
                    <div class="breadcrumb-item" @onclick="@(() => NavigateToPath(capturedPath))">
                        @segment.Name
                    </div>
                }
            </div>
        </div>

        <!-- Content Area -->
        @if (isLoading)
        {
            <div class="empty-state">
                <FluentProgressRing />
            </div>
        }
        else if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="empty-state">
                <FluentMessageBar Intent="MessageIntent.Error">
                    @errorMessage
                </FluentMessageBar>
            </div>
        }
        else if (DisplayedFiles.Count == 0)
        {
            <div class="empty-state">
                <div class="empty-state-icon">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Folder())" />
                </div>
                <div class="empty-state-title">
                    @(string.IsNullOrEmpty(searchQuery) ? "This folder is empty" : "No files found")
                </div>
                <div class="empty-state-text">
                    @(string.IsNullOrEmpty(searchQuery) ? "Upload files or create a new folder to get started" : "Try adjusting your search query")
                </div>
            </div>
        }
        else
        {
            @if (viewMode == ViewMode.Grid)
            {
                <div class="file-grid-container">
                    <div class="file-grid">
                        @foreach (var item in DisplayedFiles)
                        {
                            var isSelected = selectedItems.Contains(item);
                            <div class="file-card @(isSelected ? "selected" : "")"
                                 @onclick="@((e) => OnCardClick(item, e))"
                                 @ondblclick="@(() => OnItemClick(item))">
                                @if (isSelected)
                                {
                                    <div class="file-card-checkbox">
                                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Filled.Size20.CheckmarkCircle())" Color="@Color.Accent" />
                                    </div>
                                }
                                <div class="file-card-thumbnail">
                                    @if (IsImageFile(item) && !string.IsNullOrEmpty(item.ThumbnailData))
                                    {
                                        <img src="@item.ThumbnailData" alt="@item.Name" class="file-card-thumbnail" />
                                    }
                                    else
                                    {
                                        <div class="file-card-icon">
                                            <img src="@GetFileIcon(item)" alt="@item.Name" class="file-type-icon" />
                                        </div>
                                    }
                                </div>
                                <div class="file-card-name" title="@item.Name">@item.Name</div>
                                <div class="file-card-meta">@item.SizeDisplay</div>
                            </div>
                        }
                    </div>
                </div>
            }
            else
            {
                <div class="file-list-container">
                    <div class="file-list-header">
                        <div>Name</div>
                        <div>Size</div>
                        <div>Modified</div>
                        <div>Actions</div>
                    </div>
                    @foreach (var item in DisplayedFiles)
                    {
                        <div class="file-list-row">
                            <div class="file-list-name">
                                <img src="@GetFileIcon(item)" alt="@item.Name" class="file-type-icon-small" />
                                <span class="file-list-name-text" @onclick="@(() => OnItemClick(item))">
                                    @item.Name
                                </span>
                            </div>
                            <div>@item.SizeDisplay</div>
                            <div>@item.LastModified.ToString("yyyy-MM-dd HH:mm")</div>
                            <div class="file-list-actions">
                                @if (!item.IsDirectory)
                                {
                                    <FluentButton Appearance="Appearance.Lightweight"
                                                  OnClick="@(() => DownloadFile(item))"
                                                  Title="Download">
                                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowDownload())" />
                                    </FluentButton>
                                    @if (IsImageFile(item))
                                    {
                                        <FluentButton Appearance="Appearance.Lightweight"
                                                      OnClick="@(() => PreviewImage(item))"
                                                      Title="Preview">
                                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Eye())" />
                                        </FluentButton>
                                    }
                                }
                                <FluentButton Appearance="Appearance.Lightweight"
                                              OnClick="@(() => OpenRenameDialog(item))"
                                              Title="Rename">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Rename())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight"
                                              OnClick="@(() => OpenCopyMoveDialog(item, false))"
                                              Title="Copy">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Copy())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight"
                                              OnClick="@(() => OpenCopyMoveDialog(item, true))"
                                              Title="Move">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ArrowRight())" />
                                </FluentButton>
                                <FluentButton Appearance="Appearance.Lightweight"
                                              OnClick="@(() => DeleteItem(item))"
                                              Title="Delete">
                                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Delete())" Color="Color.Error" />
                                </FluentButton>
                            </div>
                        </div>
                    }
                </div>
            }
        }
        <!-- Bottom Action Bar (shown when items are selected) -->
        @if (selectedItems.Any())
        {
            <FluentToolbar>
                <FluentStack Orientation="Orientation.Horizontal">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.CheckmarkCircle())" Color="@Color.Accent" />
                    <FluentLabel>@selectedItems.Count @(selectedItems.Count == 1 ? "item" : "items") selected</FluentLabel>
                    <FluentSpacer></FluentSpacer>
                    @if (selectedItems.Count == 1)
                    {
                        <FluentButton Appearance="Appearance.Lightweight" OnClick="@RenameSelectedItem" Title="Rename" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Rename())">
                            Rename
                        </FluentButton>
                    }
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@DownloadSelected" Title="Download" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowDownload())">
                        Download
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenMoveDialog" Title="Move" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowMove())">
                        Move
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@OpenCopyDialog" Title="Copy" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Copy())">
                        Copy
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@DeleteSelected" Title="Delete" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Delete().WithColor("red"))">
                        Delete
                    </FluentButton>
                    <FluentButton Appearance="Appearance.Lightweight" OnClick="@(() => selectedItems.Clear())" Title="Clear Selection" IconStart="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Dismiss())">
                    </FluentButton>
                </FluentStack>
            </FluentToolbar>
        }
    </div>
</div>

<!-- Create Folder Dialog -->
<FluentDialog @ref="createFolderDialog" @bind-Hidden="@isCreateFolderDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.FolderAdd())" />
            <FluentLabel Typo="Typography.PaneHeader">Create New Folder</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="newFolderName"
                         Label="Folder Name"
                         Required="true"
                         Style="width: 100%;"
                         @onkeydown="@(async (e) => { if (e.Key == "Enter") await CreateFolder(); })" />
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@CreateFolder">Create</FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isCreateFolderDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Upload Dialog with Dropzone -->
<FluentDialog @ref="uploadDialog" @bind-Hidden="@isUploadDialogHidden" TrapFocus="true" Modal="true" Style="min-width: 600px;">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.ArrowUpload())" />
            <FluentLabel Typo="Typography.PaneHeader">Upload Files</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="15">
            <!-- Dropzone Area -->
            <div id="dropzone-upload" class="dropzone-container">
                <div class="dz-message" data-dz-message>
                    <div style="padding: 40px 20px;">
                        <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.CloudArrowUp())"
                                    Style="font-size: 48px; color: var(--accent-fill-rest); margin-bottom: 16px;" />
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">
                            Drag files here or click to browse
                        </div>
                        <div style="font-size: 13px; color: var(--neutral-foreground-hint);">
                            Support for chunked upload of large files (up to 10GB)
                        </div>
                    </div>
                </div>
            </div>

            <!-- Upload Progress -->
            @if (uploadingFiles.Any())
            {
                <div class="upload-progress-container">
                    <FluentLabel Typo="Typography.Body" Style="font-weight: 600; margin-bottom: 8px;">
                        Uploading @uploadingFiles.Count file(s)...
                    </FluentLabel>
                    @foreach (var file in uploadingFiles.Take(5))
                    {
                        <div class="upload-file-progress">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="font-size: 13px;">@file.Key</span>
                                <span style="font-size: 13px; color: var(--accent-fill-rest);">@file.Value%</span>
                            </div>
                            <FluentProgress Min="0" Max="100" Value="@file.Value" />
                        </div>
                    }
                    @if (uploadingFiles.Count > 5)
                    {
                        <FluentLabel Typo="Typography.Body">and @(uploadingFiles.Count - 5) more...</FluentLabel>
                    }
                </div>
            }

            @if (!string.IsNullOrEmpty(uploadStatusMessage))
            {
                <FluentMessageBar Intent="@uploadMessageIntent">
                    @uploadStatusMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent"
                      OnClick="@StartUpload"
                      Disabled="@isUploading">
            Start Upload
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral"
                      OnClick="@CancelUpload"
                      Disabled="@isUploading">
            @(isUploading ? "Close" : "Cancel")
        </FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Rename Dialog -->
<FluentDialog @ref="renameDialog" @bind-Hidden="@isRenameDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Rename())" />
            <FluentLabel Typo="Typography.PaneHeader">Rename</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="newItemName"
                         Label="New Name"
                         Required="true"
                         Style="width: 100%;"
                         @onkeydown="@(async (e) => { if (e.Key == "Enter") await RenameItem(); })" />
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@RenameItem">Rename</FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isRenameDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Copy/Move Dialog -->
<FluentDialog @ref="copyMoveDialog" @bind-Hidden="@isCopyMoveDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@GetCopyMoveIcon()" />
            <FluentLabel Typo="Typography.PaneHeader">@(isMoveOperation ? "Move" : "Copy") to...</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentTextField @bind-Value="destinationPath"
                         Label="Destination Path"
                         Required="true"
                         Placeholder="@currentPath"
                         Style="width: 100%;" />
        <FluentLabel Typo="Typography.Body">Current: @currentPath</FluentLabel>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@PerformCopyMove">
            @(isMoveOperation ? "Move" : "Copy")
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isCopyMoveDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Image Preview Dialog -->
<FluentDialog @ref="previewDialog" @bind-Hidden="@isPreviewDialogHidden" TrapFocus="true" Modal="true" Style="max-width: 90vw; max-height: 90vh;">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Image())" />
            <FluentLabel Typo="Typography.PaneHeader">@previewFileName</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        @if (!string.IsNullOrEmpty(previewImageData))
        {
            <img src="@previewImageData" alt="Preview" style="max-width: 100%; max-height: 70vh; object-fit: contain;" />
        }
        else
        {
            <FluentProgressRing />
        }
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isPreviewDialogHidden = true)">Close</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Favorites Dialog -->
<FluentDialog @ref="favoritesDialog" @bind-Hidden="@isFavoritesDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Star())" />
            <FluentLabel Typo="Typography.PaneHeader">Manage Favorites</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
            <FluentButton Appearance="Appearance.Accent" OnClick="@AddCurrentToFavorites">
                <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Add())" />
                Add Current Folder
            </FluentButton>
            @if (favoriteFolders.Any())
            {
                <FluentDivider />
                @foreach (var favorite in favoriteFolders)
                {
                    <FluentStack Orientation="Orientation.Horizontal" VerticalAlignment="VerticalAlignment.Center">
                        <FluentIcon Value="@(GetFavoriteIcon(favorite.Icon))" />
                        <FluentLabel Style="flex: 1;">@favorite.Name</FluentLabel>
                        <FluentButton Appearance="Appearance.Lightweight"
                                      OnClick="@(() => RemoveFromFavorites(favorite.Id))">
                            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Delete())" Color="Color.Error" />
                        </FluentButton>
                    </FluentStack>
                }
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isFavoritesDialogHidden = true)">Close</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Delete Confirmation Dialog -->
<FluentDialog @ref="deleteDialog" @bind-Hidden="@isDeleteDialogHidden" TrapFocus="true" Modal="true">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Delete())" Color="Color.Error" />
            <FluentLabel Typo="Typography.PaneHeader">Confirm Delete</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
            <FluentLabel>Are you sure you want to delete this @(itemToDelete?.IsDirectory == true ? "folder" : "file")?</FluentLabel>
            <FluentLabel Style="font-weight: bold;">@itemToDelete?.Name</FluentLabel>
            @if (itemToDelete?.IsDirectory == true)
            {
                <FluentMessageBar Intent="MessageIntent.Warning">
                    Warning: This will delete the folder and all its contents.
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@ConfirmDelete" Style="background-color: var(--error);">
            Delete
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isDeleteDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Background Task Creation Dialog -->
<FluentDialog @ref="backgroundTaskDialog" @bind-Hidden="@isBackgroundTaskDialogHidden" TrapFocus="true" Modal="true" Style="min-width: 500px;">
    <FluentDialogHeader ShowDismiss="true">
        <FluentStack VerticalAlignment="VerticalAlignment.Center">
            <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.TaskListSquareLtr())" />
            <FluentLabel Typo="Typography.PaneHeader">Create Background Task</FluentLabel>
        </FluentStack>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical" VerticalGap="15">
            <FluentLabel Style="font-weight: 500;">Create scheduled tasks to generate thumbnails and build search indexes for the current directory.</FluentLabel>
            
            <FluentLabel>Directory: @currentPath</FluentLabel>
            
            <FluentCheckbox @bind-Value="@taskRecursive" Label="Include subdirectories (recursive)" />
            
            <FluentDivider />
            
            <FluentStack Orientation="Orientation.Vertical" VerticalGap="10">
                <FluentLabel Typo="Typography.Subject">Available Tasks:</FluentLabel>
                
                <FluentCheckbox @bind-Value="@createThumbnailTask" Label="Generate Thumbnails">
                    Generate thumbnails for images and videos in this directory
                </FluentCheckbox>
                
                <FluentCheckbox @bind-Value="@createIndexTask" Label="Build Search Index">
                    Create a search index for fast file searching
                </FluentCheckbox>
            </FluentStack>
            
            <FluentDivider />
            
            <FluentStack Orientation="Orientation.Vertical" VerticalGap="5">
                <FluentLabel Typo="Typography.Subject">Schedule:</FluentLabel>
                <FluentLabel Style="font-size: 12px; color: var(--neutral-foreground-rest);">
                    Tasks will run immediately and can be set to run periodically. Default: Run once now.
                </FluentLabel>
                <FluentTextField @bind-Value="@taskCronExpression" 
                               Label="Cron Expression (optional)" 
                               Placeholder="0 0 * * * (daily at midnight)"
                               Style="width: 100%;" />
            </FluentStack>
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="@CreateBackgroundTasks">
            Create Tasks
        </FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="@(() => isBackgroundTaskDialogHidden = true)">Cancel</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

@code {
    [Parameter]
    public string? InitialPath { get; set; }

    private enum ViewMode { List, Grid }

    private const string ParentDirectoryMarker = "..";

    private ViewMode viewMode = ViewMode.Grid;
    private string currentPath = "/";
    private List<FileItemInfo> fileItems = new();
    private List<FileItemInfo> DisplayedFiles => string.IsNullOrEmpty(searchQuery) ? fileItems : searchResults;
    private List<FileItemInfo> searchResults = new();
    private List<FavoriteFolder> favoriteFolders = new();
    private List<DriveItemInfo> availableDrives = new();
    private readonly HashSet<FileItemInfo> selectedItems = new();
    private bool isLoading = true;
    private string errorMessage = string.Empty;
    private string searchQuery = string.Empty;
    private (long total, long available) storageInfo;

    // Dialog states
    private FluentDialog? createFolderDialog;
    private FluentDialog? uploadDialog;
    private FluentDialog? renameDialog;
    private FluentDialog? copyMoveDialog;
    private FluentDialog? previewDialog;
    private FluentDialog? favoritesDialog;
    private FluentDialog? deleteDialog;
    private FluentDialog? backgroundTaskDialog;

    private bool isCreateFolderDialogHidden = true;
    private bool isUploadDialogHidden = true;
    private bool isRenameDialogHidden = true;
    private bool isCopyMoveDialogHidden = true;
    private bool isPreviewDialogHidden = true;
    private bool isFavoritesDialogHidden = true;
    private bool isDeleteDialogHidden = true;
    private bool isBackgroundTaskDialogHidden = true;

    // Dialog data
    private string newFolderName = string.Empty;
    private string newItemName = string.Empty;
    private string destinationPath = string.Empty;
    private FileItemInfo? selectedItem;
    private FileItemInfo? itemToDelete;
    private bool isMoveOperation = false;
    private string previewImageData = string.Empty;
    private string previewFileName = string.Empty;

    // Background task dialog
    private bool taskRecursive = false;
    private bool createThumbnailTask = true;
    private bool createIndexTask = true;
    private string taskCronExpression = string.Empty;

    // Upload
    private List<IBrowserFile> selectedFiles = new();
    private bool isUploading = false;
    private string uploadProgress = string.Empty;
    private readonly Dictionary<string, int> uploadingFiles = new();
    private string uploadStatusMessage = string.Empty;
    private MessageIntent uploadMessageIntent = MessageIntent.Info;
    private DotNetObjectReference<FileManager>? dotNetHelper;

    private bool IsRootPath => string.IsNullOrEmpty(currentPath) || currentPath == "/" || currentPath == "\\";

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(InitialPath))
        {
            currentPath = InitialPath;
        }
        await LoadFavorites();
        await LoadDrives();
        await LoadFiles();
    }

    private async Task LoadDrives()
    {
        try
        {
            availableDrives = await FileService.GetDrivesAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading drives");
        }
    }

    private void OnCardClick(FileItemInfo item, Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        // Ctrl/Cmd key for multi-select
        if (e.CtrlKey || e.MetaKey)
        {
            if (selectedItems.Contains(item))
            {
                selectedItems.Remove(item);
            }
            else
            {
                selectedItems.Add(item);
            }
        }
        // Shift key for range select (simple implementation)
        else if (e.ShiftKey && selectedItems.Any())
        {
            var lastSelected = selectedItems.Last();
            var startIndex = DisplayedFiles.IndexOf(lastSelected);
            var endIndex = DisplayedFiles.IndexOf(item);

            if (startIndex >= 0 && endIndex >= 0)
            {
                var start = Math.Min(startIndex, endIndex);
                var end = Math.Max(startIndex, endIndex);

                for (int i = start; i <= end; i++)
                {
                    selectedItems.Add(DisplayedFiles[i]);
                }
            }
        }
        // Single click without modifiers - select only this item
        else
        {
            selectedItems.Clear();
            selectedItems.Add(item);
        }
    }

    private async Task LoadThumbnails()
    {
        // Load thumbnails for image and video files in grid view
        if (viewMode != ViewMode.Grid)
        {
            // Clear thumbnail data when not in grid view to save memory
            foreach (var item in fileItems)
            {
                item.ThumbnailData = null;
            }
            return;
        }

        try
        {
            var mediaFiles = fileItems.Where(f => !f.IsDirectory && (IsImageFile(f) || IsVideoFile(f))).ToList();

            // Load thumbnails in parallel for better performance
            var thumbnailTasks = mediaFiles.Select(async item =>
            {
                try
                {
                    var thumbnailData = await ThumbnailService.GetThumbnailAsync(item.Path);
                    if (thumbnailData != null)
                    {
                        item.ThumbnailData = $"data:image/jpeg;base64,{Convert.ToBase64String(thumbnailData)}";
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogWarning(ex, "Failed to load thumbnail for {Path}", item.Path);
                }
            });

            await Task.WhenAll(thumbnailTasks);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading thumbnails");
        }
    }

    /// <summary>
    /// Loads files and folders from the current path
    /// </summary>
    private async Task LoadFiles()
    {
        isLoading = true;
        errorMessage = string.Empty;

        try
        {
            fileItems = await FileService.GetFilesAsync(currentPath);

            // Sort: directories first, then by name
            fileItems = fileItems
                .OrderBy(f => f.IsDirectory ? 0 : 1)
                .ThenBy(f => f.Name)
                .ToList();

            // Get storage info for the drive containing current path
            try
            {
                storageInfo = await FileService.GetStorageInfoAsync(currentPath);
                StateHasChanged(); // Ensure UI updates with new storage info
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to get storage info for path: {Path}", currentPath);
                // Storage info is optional
                storageInfo = (0, 0);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading files from path: {Path}", currentPath);
            errorMessage = $"Failed to load files: {ex.Message}";
            ToastService.ShowError($"Failed to load files: {ex.Message}");
        }
        finally
        {
            isLoading = false;
        }

        // Load thumbnails after files are loaded
        await LoadThumbnails();

        // Force UI update to ensure storage info is displayed
        StateHasChanged();
    }

    private async Task LoadFavorites()
    {
        try
        {
            favoriteFolders = await FileService.GetFavoriteFoldersAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading favorite folders");
        }
    }

    private async Task RefreshFiles()
    {
        await LoadFiles();
        ToastService.ShowSuccess("Files refreshed");
    }

    private async Task NavigateUp()
    {
        if (!IsRootPath)
        {
            var parentPath = FileService.GetParentPath(currentPath);
            await NavigateToPath(parentPath);
        }
    }

    private async Task NavigateToPath(string path)
    {
        currentPath = path;
        searchQuery = string.Empty;
        searchResults.Clear();
        selectedItems.Clear(); // Clear selection when navigating
        await LoadFiles();
    }

    private async Task OnItemClick(FileItemInfo item)
    {
        if (item.IsDirectory)
        {
            await NavigateToPath(item.Path);
        }
        else if (IsImageFile(item))
        {
            await PreviewImage(item);
        }
        else
        {
            await DownloadFile(item);
        }
    }

    private bool IsPathOnDisk(string path, string diskPath)
    {
        // Normalize paths for comparison (handle both Unix and Windows separators)
        var normalizedPath = path.TrimEnd('/', '\\');
        var normalizedDiskPath = diskPath.TrimEnd('/', '\\');

        // Special handling for root path
        if (normalizedDiskPath == "" || normalizedDiskPath == "/")
        {
            normalizedDiskPath = "/";
            // Root disk is active only if path is exactly "/" or doesn't match any other disk
            // This will be handled by checking other disks first
            if (normalizedPath == "" || normalizedPath == "/")
            {
                return true;
            }
            // Check if path starts with any non-root disk path
            // If it does, then root is NOT active
            foreach (var drive in availableDrives)
            {
                var otherDiskPath = drive.Path.TrimEnd('/', '\\');
                if (otherDiskPath != "" && otherDiskPath != "/" && normalizedPath.StartsWith(otherDiskPath, StringComparison.OrdinalIgnoreCase))
                {
                    return false;
                }
            }
            // If no other disk matches, root is active
            return true;
        }

        // For non-root disks, check if path starts with disk path
        return normalizedPath.StartsWith(normalizedDiskPath, StringComparison.OrdinalIgnoreCase);
    }

    private List<(string Name, string Path)> GetPathSegments()
    {
        var segments = new List<(string, string)>();
        if (string.IsNullOrEmpty(currentPath) || currentPath == "/") return segments;

        var parts = currentPath.Split(new[] { '/', '\\' }, StringSplitOptions.RemoveEmptyEntries);
        var pathBuilder = new System.Text.StringBuilder();

        foreach (var part in parts)
        {
            pathBuilder.Append('/');
            pathBuilder.Append(part);
            segments.Add((part, pathBuilder.ToString()));
        }

        return segments;
    }

    private async Task ToggleViewMode()
    {
        viewMode = viewMode == ViewMode.List ? ViewMode.Grid : ViewMode.List;

        // Load thumbnails when switching to grid view
        if (viewMode == ViewMode.Grid)
        {
            await LoadThumbnails();
        }
    }

    #region File Operations

    private void OpenCreateFolderDialog()
    {
        newFolderName = string.Empty;
        isCreateFolderDialogHidden = false;
    }

    private async Task CreateFolder()
    {
        if (string.IsNullOrWhiteSpace(newFolderName))
        {
            ToastService.ShowWarning("Please enter a folder name");
            return;
        }

        // Validate folder name for path traversal attempts
        if (newFolderName.Contains("..") ||
            newFolderName.Contains("/") ||
            newFolderName.Contains("\\") ||
            Path.GetInvalidFileNameChars().Any(c => newFolderName.Contains(c)))
        {
            ToastService.ShowError("Invalid folder name. Please avoid special characters and path separators.");
            return;
        }

        try
        {
            var folderPath = Path.Combine(currentPath, newFolderName);
            await FileService.CreateDirectoryAsync(folderPath);
            ToastService.ShowSuccess($"Folder '{newFolderName}' created successfully");
            isCreateFolderDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating folder: {Name}", newFolderName);
            ToastService.ShowError($"Failed to create folder: {ex.Message}");
        }
    }

    private void DeleteItem(FileItemInfo item)
    {
        itemToDelete = item;
        isDeleteDialogHidden = false;
    }

    private async Task ConfirmDelete()
    {
        if (itemToDelete == null) return;

        try
        {
            if (itemToDelete.IsDirectory)
            {
                await FileService.DeleteDirectoryAsync(itemToDelete.Path);
            }
            else
            {
                await FileService.DeleteFileAsync(itemToDelete.Path);
            }

            ToastService.ShowSuccess($"'{itemToDelete.Name}' deleted successfully");
            isDeleteDialogHidden = true;
            itemToDelete = null;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error deleting item: {Path}", itemToDelete?.Path);
            ToastService.ShowError($"Failed to delete: {ex.Message}");
            isDeleteDialogHidden = true;
            itemToDelete = null;
        }
    }

    private void OpenRenameDialog(FileItemInfo item)
    {
        selectedItem = item;
        newItemName = item.Name;
        isRenameDialogHidden = false;
    }

    private async Task RenameItem()
    {
        if (selectedItem == null || string.IsNullOrWhiteSpace(newItemName))
        {
            ToastService.ShowWarning("Please enter a new name");
            return;
        }

        try
        {
            var newPath = Path.Combine(Path.GetDirectoryName(selectedItem.Path) ?? currentPath, newItemName);
            await FileService.RenameAsync(selectedItem.Path, newPath);
            ToastService.ShowSuccess($"Renamed to '{newItemName}' successfully");
            isRenameDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error renaming item: {Path}", selectedItem.Path);
            ToastService.ShowError($"Failed to rename: {ex.Message}");
        }
    }

    private void OpenCopyMoveDialog(FileItemInfo item, bool isMove)
    {
        selectedItem = item;
        isMoveOperation = isMove;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private async Task PerformCopyMove()
    {
        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            ToastService.ShowWarning("Please enter a destination path");
            return;
        }

        // Handle batch operations from action bar
        if (selectedItems.Any())
        {
            var successCount = 0;
            var failCount = 0;
            var operation = isMoveOperation ? "move" : "copy";

            foreach (var item in selectedItems.ToList())
            {
                try
                {
                    var destPath = Path.Combine(destinationPath, item.Name);

                    if (isMoveOperation)
                    {
                        await FileService.MoveAsync(item.Path, destPath);
                    }
                    else
                    {
                        await FileService.CopyAsync(item.Path, destPath);
                    }

                    successCount++;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error {Operation} item: {Path}", operation, item.Path);
                    failCount++;
                }
            }

            if (successCount > 0)
            {
                ToastService.ShowSuccess($"Successfully {operation}d {successCount} item(s)");
            }
            if (failCount > 0)
            {
                ToastService.ShowError($"Failed to {operation} {failCount} item(s)");
            }

            selectedItems.Clear();
            isCopyMoveDialogHidden = true;
            await LoadFiles();
            return;
        }

        // Handle single item from context menu
        if (selectedItem == null)
        {
            ToastService.ShowWarning("Please select an item");
            return;
        }

        try
        {
            var destPath = Path.Combine(destinationPath, selectedItem.Name);

            if (isMoveOperation)
            {
                await FileService.MoveAsync(selectedItem.Path, destPath);
                ToastService.ShowSuccess($"Moved '{selectedItem.Name}' successfully");
            }
            else
            {
                await FileService.CopyAsync(selectedItem.Path, destPath);
                ToastService.ShowSuccess($"Copied '{selectedItem.Name}' successfully");
            }

            isCopyMoveDialogHidden = true;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error {Operation} item: {Path}", isMoveOperation ? "moving" : "copying", selectedItem.Path);
            ToastService.ShowError($"Failed to {(isMoveOperation ? "move" : "copy")}: {ex.Message}");
        }
    }

    private async Task DownloadFile(FileItemInfo file)
    {
        try
        {
            var fileData = await FileService.DownloadFileAsync(file.Path);

            // Use JS interop to trigger download
            await JSRuntime.InvokeVoidAsync("downloadFile", file.Name, Convert.ToBase64String(fileData));
            ToastService.ShowSuccess($"Downloading '{file.Name}'");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading file: {Path}", file.Path);
            ToastService.ShowError($"Failed to download: {ex.Message}");
        }
    }

    #endregion

    #region Upload

    private async Task OpenUploadDialog()
    {
        uploadingFiles.Clear();
        uploadStatusMessage = string.Empty;
        isUploading = false;
        isUploadDialogHidden = false;

        // Initialize dropzone after dialog renders
        await Task.Delay(100);
        await InitializeDropzone();
    }

    private async Task InitializeDropzone()
    {
        try
        {
            // Wait a bit longer for dropzone script to load
            await Task.Delay(300);

            dotNetHelper = DotNetObjectReference.Create(this);
            var uploadUrl = "/api/files/upload-chunk";
            await JSRuntime.InvokeVoidAsync("initializeChunkedDropzone",
                "dropzone-upload",
                uploadUrl,
                currentPath,
                dotNetHelper,
                1048576); // 1MB chunks
        }
        catch (JSException jsEx) when (jsEx.Message.Contains("Dropzone is not defined"))
        {
            Logger.LogError(jsEx, "Dropzone library not loaded");
            uploadStatusMessage = "Upload component not ready. Please refresh the page.";
            uploadMessageIntent = MessageIntent.Error;
            ToastService.ShowError("Dropzone.js library failed to load. Please check your internet connection and refresh the page.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing dropzone");
            uploadStatusMessage = $"Failed to initialize upload: {ex.Message}";
            uploadMessageIntent = MessageIntent.Error;
            ToastService.ShowError("Failed to initialize upload component");
        }
    }

    private async Task StartUpload()
    {
        try
        {
            isUploading = true;
            uploadStatusMessage = "Starting upload...";
            uploadMessageIntent = MessageIntent.Info;
            StateHasChanged();

            await JSRuntime.InvokeVoidAsync("processDropzoneQueue", "dropzone-upload");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting upload");
            uploadStatusMessage = $"Failed to start upload: {ex.Message}";
            uploadMessageIntent = MessageIntent.Error;
            isUploading = false;
        }
    }

    private async Task CancelUpload()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("clearDropzone", "dropzone-upload");
            uploadingFiles.Clear();
            uploadStatusMessage = string.Empty;
            isUploadDialogHidden = true;
            isUploading = false;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error canceling upload");
        }
    }

    [JSInvokable]
    public Task OnUploadProgress(string fileId, string filename, int progress, long bytesSent, long totalBytes)
    {
        // Use fileId (UUID) as key to avoid collisions with same filename
        if (!string.IsNullOrWhiteSpace(fileId))
        {
            uploadingFiles[fileId] = progress;
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnFileUploaded(string fileId, string filename)
    {
        if (!string.IsNullOrWhiteSpace(fileId))
        {
            uploadingFiles.Remove(fileId);
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnUploadError(string fileId, string filename, string error)
    {
        if (!string.IsNullOrWhiteSpace(fileId))
        {
            uploadingFiles.Remove(fileId);
        }

        // Validate filename to prevent log injection
        var safeFilename = string.IsNullOrWhiteSpace(filename) ? "unknown" : Path.GetFileName(filename);
        uploadStatusMessage = $"Error uploading {safeFilename}: {error}";
        uploadMessageIntent = MessageIntent.Error;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task OnAllUploadsComplete()
    {
        uploadStatusMessage = "All files uploaded successfully!";
        uploadMessageIntent = MessageIntent.Success;
        isUploading = false;
        StateHasChanged();

        await Task.Delay(1500);
        await LoadFiles();
        isUploadDialogHidden = true;
    }

    private void HandleFileSelection(InputFileChangeEventArgs e)
    {
        selectedFiles = e.GetMultipleFiles(100).ToList();
    }

    private async Task UploadFiles()
    {
        if (!selectedFiles.Any()) return;

        isUploading = true;
        var uploadedCount = 0;

        try
        {
            foreach (var file in selectedFiles)
            {
                // Validate filename for path traversal attempts
                if (string.IsNullOrWhiteSpace(file.Name) ||
                    file.Name.Contains("..") ||
                    file.Name.Contains("/") ||
                    file.Name.Contains("\\") ||
                    Path.GetInvalidFileNameChars().Any(c => file.Name.Contains(c)))
                {
                    ToastService.ShowError($"Invalid filename: {file.Name}");
                    continue;
                }

                uploadProgress = $"{uploadedCount + 1} / {selectedFiles.Count}";
                StateHasChanged();

                using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 1024); // 1GB max
                await FileService.UploadFileStreamAsync(currentPath, file.Name, stream, file.Size);
                uploadedCount++;
            }

            ToastService.ShowSuccess($"Uploaded {uploadedCount} file(s) successfully");
            isUploadDialogHidden = true;
            selectedFiles.Clear();
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error uploading files");
            ToastService.ShowError($"Upload failed: {ex.Message}");
        }
        finally
        {
            isUploading = false;
            uploadProgress = string.Empty;
        }
    }

    #endregion

    #region Preview

    private async Task PreviewImage(FileItemInfo file)
    {
        previewFileName = file.Name;
        previewImageData = string.Empty;
        isPreviewDialogHidden = false;

        try
        {
            // Check file size before loading (e.g., warn if > 10MB)
            var fileInfo = new System.IO.FileInfo(file.Path);
            if (fileInfo.Length > 10 * 1024 * 1024) // 10MB limit for preview
            {
                ToastService.ShowWarning($"File is large ({fileInfo.Length / 1024 / 1024}MB). Preview may be slow.");
            }

            var imageData = await FileService.DownloadFileAsync(file.Path);
            var base64 = Convert.ToBase64String(imageData);
            var mimeType = GetMimeType(file.Extension);
            previewImageData = $"data:{mimeType};base64,{base64}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading image preview: {Path}", file.Path);
            ToastService.ShowError($"Failed to load preview: {ex.Message}");
            isPreviewDialogHidden = true;
        }
    }

    private bool IsImageFile(FileItemInfo file)
    {
        if (file.IsDirectory) return false;
        var ext = file.Extension.ToLowerInvariant();
        return ext is ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" or ".svg";
    }

    private bool IsVideoFile(FileItemInfo file)
    {
        if (file.IsDirectory) return false;
        var ext = file.Extension.ToLowerInvariant();
        return ext is ".mp4" or ".avi" or ".mov" or ".mkv" or ".wmv" or ".flv" or ".webm" or ".m4v";
    }

    private string GetMimeType(string extension)
    {
        return extension.ToLowerInvariant() switch
        {
            ".jpg" or ".jpeg" => "image/jpeg",
            ".png" => "image/png",
            ".gif" => "image/gif",
            ".bmp" => "image/bmp",
            ".webp" => "image/webp",
            ".svg" => "image/svg+xml",
            _ => "application/octet-stream"
        };
    }

    #endregion

    #region Search

    private async Task OnSearchChanged()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            searchResults.Clear();
            return;
        }

        try
        {
            // Check if index exists for current directory or parent directories
            var hasIndex = await FileIndexService.HasIndexAsync(currentPath);
            
            if (!hasIndex)
            {
                // No index found, prompt user to create one
                ToastService.ShowWarning("No search index found. Please create an index for this directory to enable search.");
                searchResults.Clear();
                return;
            }

            // Search using the index
            var indexResults = await FileIndexService.SearchFilesInDirectoryAsync(currentPath, searchQuery);
            
            // Convert FileIndex to FileItemInfo
            searchResults = indexResults.Select(fi => new FileItemInfo
            {
                Name = fi.FileName,
                Path = fi.FilePath,
                Size = fi.FileSize,
                LastModified = fi.ModifiedAt,
                IsDirectory = false,
                Extension = fi.FileType
            }).ToList();
            
            ToastService.ShowInfo($"Found {searchResults.Count} items");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error searching files: {Query}", searchQuery);
            ToastService.ShowError($"Search failed: {ex.Message}");
        }
    }

    #endregion

    #region Favorites

    private void OpenFavoritesDialog()
    {
        isFavoritesDialogHidden = false;
    }

    private async Task AddCurrentToFavorites()
    {
        try
        {
            var folderName = Path.GetFileName(currentPath);
            if (string.IsNullOrEmpty(folderName))
            {
                folderName = currentPath;
            }

            await FileService.AddFavoriteFolderAsync(folderName, currentPath);
            await LoadFavorites();
            ToastService.ShowSuccess($"Added '{folderName}' to favorites");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding favorite folder: {Path}", currentPath);
            ToastService.ShowError($"Failed to add favorite: {ex.Message}");
        }
    }

    private async Task RemoveFromFavorites(int id)
    {
        try
        {
            await FileService.RemoveFavoriteFolderAsync(id);
            await LoadFavorites();
            ToastService.ShowSuccess("Removed from favorites");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error removing favorite folder: {Id}", id);
            ToastService.ShowError($"Failed to remove favorite: {ex.Message}");
        }
    }

    #endregion

    #region Background Tasks

    private void OpenBackgroundTaskDialog()
    {
        // Reset dialog state
        taskRecursive = false;
        createThumbnailTask = true;
        createIndexTask = true;
        taskCronExpression = string.Empty;
        
        isBackgroundTaskDialogHidden = false;
    }

    private async Task CreateBackgroundTasks()
    {
        try
        {
            if (!createThumbnailTask && !createIndexTask)
            {
                ToastService.ShowWarning("Please select at least one task type");
                return;
            }

            var tasksCreated = 0;

            // Use a default cron expression if none provided (run immediately, don't repeat)
            var cronExpr = string.IsNullOrWhiteSpace(taskCronExpression) ? "0 0 0 1 1 ? 2099" : taskCronExpression;

            // Create thumbnail generation task
            if (createThumbnailTask)
            {
                var thumbnailTask = new ScheduledTask
                {
                    Name = $"Generate Thumbnails - {Path.GetFileName(currentPath) ?? currentPath}",
                    Description = $"Generate thumbnails for {currentPath}" + (taskRecursive ? " (recursive)" : ""),
                    TaskType = "ThumbnailGeneration",
                    TaskData = System.Text.Json.JsonSerializer.Serialize(new Dictionary<string, string>
                    {
                        { "path", currentPath },
                        { "recursive", taskRecursive.ToString().ToLower() }
                    }),
                    CronExpression = cronExpr,
                    IsEnabled = true
                };
                
                await ScheduledTaskService.CreateTaskAsync(thumbnailTask);
                tasksCreated++;
            }

            // Create indexing task
            if (createIndexTask)
            {
                var indexTask = new ScheduledTask
                {
                    Name = $"Build Search Index - {Path.GetFileName(currentPath) ?? currentPath}",
                    Description = $"Build search index for {currentPath}" + (taskRecursive ? " (recursive)" : ""),
                    TaskType = "FileIndex",
                    TaskData = System.Text.Json.JsonSerializer.Serialize(new Dictionary<string, string>
                    {
                        { "path", currentPath },
                        { "recursive", taskRecursive.ToString().ToLower() }
                    }),
                    CronExpression = cronExpr,
                    IsEnabled = true
                };
                
                await ScheduledTaskService.CreateTaskAsync(indexTask);
                tasksCreated++;
            }

            isBackgroundTaskDialogHidden = true;
            ToastService.ShowSuccess($"Created {tasksCreated} background task(s). Tasks will run shortly.");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error creating background tasks");
            ToastService.ShowError($"Failed to create tasks: {ex.Message}");
        }
    }

    #endregion

    #region Icons

    private string GetFileIcon(FileItemInfo item)
    {
        if (item.IsDirectory)
        {
            return "/images/filemanager/png/002-folder.png";
        }

        return item.Extension.ToLowerInvariant() switch
        {
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".webp" => "/images/filemanager/png/007-image.png",
            ".svg" => "/images/filemanager/png/022-svg.png",
            ".pdf" => "/images/filemanager/png/001-pdf.png",
            ".doc" or ".docx" => "/images/filemanager/png/006-word.png",
            ".xls" or ".xlsx" => "/images/filemanager/png/015-excel.png",
            ".ppt" or ".pptx" => "/images/filemanager/png/014-powerpoint.png",
            ".txt" or ".log" => "/images/filemanager/png/012-txt.png",
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => "/images/filemanager/png/008-zip.png",
            ".mp3" or ".wav" or ".flac" or ".m4a" => "/images/filemanager/png/010-music.png",
            ".mp4" or ".avi" or ".mkv" or ".mov" => "/images/filemanager/png/009-video.png",
            ".js" or ".ts" => "/images/filemanager/png/028-js-file.png",
            ".css" => "/images/filemanager/png/011-css.png",
            ".cs" or ".py" or ".java" or ".cpp" or ".c" or ".h" or ".html" or ".json" or ".xml" => "/images/filemanager/png/016-text.png",
            ".iso" => "/images/filemanager/png/018-iso.png",
            ".ttf" or ".otf" or ".woff" or ".woff2" => "/images/filemanager/png/024-font-file.png",
            ".sql" => "/images/filemanager/png/025-sql.png",
            ".apk" => "/images/filemanager/png/023-apk.png",
            ".psd" => "/images/filemanager/png/030-psd.png",
            ".ai" => "/images/filemanager/png/027-adobe-illustrator.png",
            _ => "/images/filemanager/png/013-blank.png"
        };
    }

    private Icon GetFavoriteIcon(string iconName)
    {
        return iconName.ToLowerInvariant() switch
        {
            "folder" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder(),
            "star" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Star(),
            "home" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Home(),
            "document" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Document(),
            "image" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Image(),
            "video" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Video(),
            "music" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.MusicNote2(),
            _ => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder()
        };
    }

    private Icon GetViewModeIcon()
    {
        return viewMode == ViewMode.List
            ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Grid()
            : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.TextBulletList();
    }

    private Icon GetCopyMoveIcon()
    {
        return isMoveOperation
            ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.ArrowRight()
            : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size24.Copy();
    }

    #endregion

    #region Batch Operations

    private async Task DownloadSelected()
    {
        if (!selectedItems.Any()) return;

        try
        {
            if (selectedItems.Count == 1)
            {
                // Single file download
                var item = selectedItems.First();
                if (!item.IsDirectory)
                {
                    await DownloadFile(item);
                }
                else
                {
                    ToastService.ShowInfo("Folder download will be packaged as ZIP");
                    await DownloadAsZip();
                }
            }
            else
            {
                // Multiple items - create ZIP
                await DownloadAsZip();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error downloading selected items");
            ToastService.ShowError($"Download failed: {ex.Message}");
        }
    }

    private async Task DownloadAsZip()
    {
        try
        {
            ToastService.ShowInfo("Preparing ZIP download...");

            // Create ZIP download request with selected paths
            var paths = selectedItems.Select(i => i.Path).ToList();
            var zipFileName = selectedItems.Count == 1
                ? $"{selectedItems.First().Name}.zip"
                : $"download_{DateTime.Now:yyyyMMdd_HHmmss}.zip";

            // Use direct download link instead of JavaScript interop to avoid memory issues
            var pathsJson = System.Text.Json.JsonSerializer.Serialize(paths);
            var encodedPaths = Uri.EscapeDataString(pathsJson);
            var encodedFileName = Uri.EscapeDataString(zipFileName);

            var downloadUrl = $"/api/files/download-zip?paths={encodedPaths}&filename={encodedFileName}";

            // Navigate to download URL - browser will handle the file download
            await JSRuntime.InvokeVoidAsync("open", downloadUrl, "_self");

            ToastService.ShowSuccess($"Downloading {selectedItems.Count} item(s) as ZIP");
            selectedItems.Clear();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initiating ZIP download");
            ToastService.ShowError($"Failed to start download: {ex.Message}");
        }
    }

    private void OpenMoveDialog()
    {
        if (!selectedItems.Any()) return;

        isMoveOperation = true;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private void OpenCopyDialog()
    {
        if (!selectedItems.Any()) return;

        isMoveOperation = false;
        destinationPath = currentPath;
        isCopyMoveDialogHidden = false;
    }

    private async Task DeleteSelected()
    {
        if (!selectedItems.Any()) return;

        var itemNames = string.Join(", ", selectedItems.Take(3).Select(i => i.Name));
        if (selectedItems.Count > 3)
        {
            itemNames += $" and {selectedItems.Count - 3} more";
        }

        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm",
            $"Are you sure you want to delete {selectedItems.Count} item(s)?\n\n{itemNames}");

        if (!confirmed) return;

        try
        {
            var successCount = 0;
            var failCount = 0;

            foreach (var item in selectedItems.ToList())
            {
                try
                {
                    if (item.IsDirectory)
                    {
                        await FileService.DeleteDirectoryAsync(item.Path);
                    }
                    else
                    {
                        await FileService.DeleteFileAsync(item.Path);
                    }
                    successCount++;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error deleting item: {Path}", item.Path);
                    failCount++;
                }
            }

            if (successCount > 0)
            {
                ToastService.ShowSuccess($"Deleted {successCount} item(s) successfully");
            }
            if (failCount > 0)
            {
                ToastService.ShowError($"Failed to delete {failCount} item(s)");
            }

            selectedItems.Clear();
            await LoadFiles();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error in batch delete");
            ToastService.ShowError($"Delete operation failed: {ex.Message}");
        }
    }

    private void RenameSelectedItem()
    {
        if (selectedItems.Count != 1) return;

        var item = selectedItems.First();
        OpenRenameDialog(item);
        selectedItems.Clear();
    }

    #endregion
}
